# 처리된 사람들을 pop시켜서 해결하면 됨! 자료구조가 비어버릴 때까지 작업 진행하면 됨.

n, limit = map(int, input().split())
p = list(map(int, input().split()))
p.sort()
cnt = 0
while p:     # p가 비어있지 않으면 참, p가 비어있으면 거짓
    if len(p) == 1:     # 마지막에 한명이 남았을 경우
        cnt += 1     # 그 한명을 태울 보트 1 증가
        break     # 바로 반복문 빠져나감
    if p[0] + p[-1] > limit:     # p 리스트에 존재하는 사람 중 가장 가벼운 사람과 가장 무거운 사람의 몸무게 합이 limit보다 클 때
        p.pop()     # 가장 무거운 사람(마지막 사람)은 삭제 (--> 보트를 타고 나갔다는 뜻)
        cnt += 1
    else:     # 몸무게의 합이 limit 보다 작거나 같을 경우
        p.pop(0)     # 가장 가벼운 사람(첫번째 사람) 탈출
        p.pop()     # 가장 무거운 사람(마지막 사람) 탈출
        cnt += 1     # 첫번째와 마지막 사람이 같이 하나의 보트를 타고 나가므로 cnt 1 증가
print(cnt)

# but pop을 사용하면 하나를 삭제할 때마다 모든 요소를 한칸씩 앞으로 옮기는 연산을 하기 때문에 비효율적!
# 데크라는 자료구조를 이용하면 양옆으로 요소를 뺄 수 있고, 한 요소가 빠지면 요소들이 대거 이동하는 것이 아닌 포인터 변수가 한 칸 옆으로 이동하므로 앞에 있는 자료를 pop 시킬 때 좀 더 효율적이다.