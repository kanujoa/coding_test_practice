# 최상위 부모 노드는 1, 아래로 갈수록 숫자가 1씩 커짐.
# 즉, 상태 트리를 잘 구성하면 된다. 왼쪽 노드는 부모 노드의 값을 부분집합으로 하고, 오른쪽 노드는 부모 노드의 값을 부분집합으로 하지 않게 설정한다.
# O(부모 노드의 값 포함)와 X(부모 노드의 값 포함 안함)에 따라 길이 갈리는 것으로 생각하면 된다.
# <맨 왼쪽 파고들어가기>
# 1. 부모가 1(DFS(1)) --> 왼쪽 자식은 {1}(DFS(2), 1 사용), 오른쪽 자식은 {}(DFS(2), 1 사용 X)
# 2. 부모가 {1}(DFS(2)) --> 왼쪽 자식은 {1, 2}(DFS(3), 2 사용), 오른쪽 자식은 {1}(DFS(3), 2 사용 X)
# 3. 부모가 {1, 2}(DFS(3)) --> 왼쪽 자식은 {1, 2, 3}(DFS(4), 3 사용), 오른쪽 자식은 {1, 2}(DFS(4), 3 사용 X)
# 위와 같은 식으로 트리 이어나가기!
# n = 3일 경우 DFS(4)에서 종료되고 출력되어야 함.

def DFS(v):
    if v == n+1:     # v가 n + 1이 될 경우 더 이상 뻗어나가지 말고 출력해야 함.
        for i in range(1, n+1):     # ch의 모든 요소 탐색
            if ch[i] == 1:     # 1인 부분이 있다면
                print(i, end=' ')     # 그 부분에 해당하는 index 출력 (인덱스 번호와 숫자가 일치하도록 코드를 짰다.)
        print()
    else:
        ch[v] = 1     # v 원소를 부분집합으로 설정한다.
        DFS(v+1)
        ch[v] = 0     # 하나 위로 back 하므로 ch에서 부분집합으로 설정된 부분을 0으로 바꾸어줌.
        DFS(v+1)     

n = int(input())
ch = [0] * (n+1)     # 숫자들이 부분집합으로 사용되었는지의 여부를 확인하기 위한 리스트 생성
DFS(1)