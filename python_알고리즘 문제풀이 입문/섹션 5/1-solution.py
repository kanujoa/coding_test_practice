# 각각의 숫자들은 자기 앞에 위치하는 숫자가 자신보다 작으면 안된다는 생각을 기본으로 가지고 있어야 한다.
# 자신 앞의 숫자가 자신보다 작다면 그 숫자를 삭제하고 자신이 맨 앞에 위치할 수 있다.
# 만약 지워진 숫자의 수가 최대가 되었다면 자신 앞의 숫자가 자신보다 작더라도 지우고 맨 앞으로 가는 것이 불가능함.
# 따라서 지워진 숫자의 수가 최대가 된 이후부터는 그냥 순서대로 그대로 가야함.
# 만약 지우는 횟수가 남았다면 슬라이싱을 통해 끝에 위치한 지우는 횟수만큼의 숫자들은 버림

# <스택> : 위와 같이 앞의 것을 지우고 뒤의 것이 앞으로 올 수 있게 하는 자료구조 
# Last in First Out: 나중에 들어간 것이 먼저 나온다. 들어가는 입구와 나오는 출구가 한 곳이므로!
# 리스트에서 pop()을 하면 가장 나중에 위치한 자료가 삭제되고, append()를 하면 가장 마지막 위치에 요소가 배치되는데 이는 
# python에서 스택을 구현한 예이다.


num, m = map(int, input().split())
num = list(map(int, str(num)))
stack = []     # 결괏값을 담을 리스트 (빈 리스트에서 시작, 요소들을 추가해나감.)
for x in num:
    while stack and m > 0 and stack[-1] < x:     # stack 리스트가 비어 있지 않고, m(지운 횟수)이 0보다 크면서 stack에 들어간 마지막 숫자가 현재 숫자인 x보다 작으면 끄집어 내야 한다.
        stack.pop()     # 스택의 제일 뒷자료(stack[-1])를 뺀다. stack에 이미 들어가 있는 숫자들이 여러개이고, 이에 따라 stack[-1] < x인 경우가 여러번일 수 있으므로 반복하기 위해 while을 써 주었다.
        m -= 1     # 제거해야 할 횟수는 pop 시킬 때마다 1씩 줄어든다.
    stack.append(x)     # 제거 후에는 현재 숫자 x가 맨 마지막에 들어간다.
if m != 0:     # 제거 횟수가 남은 경우
    stack = stack[:-m]     # 남은 만큼 stack의 뒷부분을 잘라준다. ([:-m]을 하면 뒷쪽의 m개의 자료가 날아간다.)
res = "".join(map(str, stack))     # for문으로 출력해도 된다.
print(res)
