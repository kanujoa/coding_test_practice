n, k = map(int, input().split())     # 컨베이어 벨트의 길이 n, 내구도 0인 칸의 개수 상한선     
c = list(map(int, input().split()))     # 내구도가 적힌 컨베이어 벨트 (내구도를 입력받아 일차원 리스트 만들기)
robots = [0] * len(c)      # 로봇이 올라가 있는 것을 확인할 배열

zero = 0     # 내구도 0 개수
cnt = 0     # 거친 단계 수
while zero < k:     # 내구도가 0인 칸의 개수가 k보다 작을 때까지만 반복
    # 벨트 1칸씩 회전 (로봇이 있을 경우 로봇과 같이, 로봇이 마지막 칸에 있을 경우 내려 주어야 함.)
    c.insert(0, c.pop())
    robots.insert(0, robots.pop())
    # 벨트 움직인 후 내려주기 (내구도 감소는 로봇을 올려놓을 때랑 이동할 때 일어남. 내릴 때는 일어나지 않음.)
    if robots[-1] == 1:
        robots[-1] = 0

    # 가장 먼저 벨트에 올라간 로봇부터 벨트가 회전하는 방향으로 한 칸 이동할 수 있으면 이동
    i = 0
    while i < len(robots):
        if robots[i] == 1 and c[i + 1] != 0 and robots[i + 1] == 0:     # 맨 끝 인덱스가 아니고 이동 가능한 경우 
            robots[i] , robots[i + 1] = 0, 1     # 현재 칸은 로봇 제거, 다음 칸에 로봇 배치
            c[i + 1] -= 1     # 다음 칸의 내구도 - 1 (현재 칸은 내구도 원상복구 안됨.)
            if c[i + 1] == 0:     # 다음 칸의 내구도가 0이 되면 
                zero += 1     # 내구도 0 개수 1 증가
            i += 2
        elif i == 2 * n - 1 and robots[i] == 1:     # 인덱스가 제일 끝일 경우 내려야 함!
            robots[i] = 0
            i += 1
        else:     # 불가능할 경우
            i += 1     # 인덱스만 1 증가

    # 올리는 위치에 있는 칸의 내구도가 0이 아니면 올리는 위치에 로봇을 올림.
    if c[0] > 0 and robots[0] == 0:
        robots[0] = 1     # 시작 위치에 로봇 추가
        c[0] -= 1     # 시작 위치 내구도 1 감소
        if c[0] == 0:     # 시작 위치의 내구도가 1이 되면
            zero += 1     # 내구도 0 개수 1 증가

    cnt += 1     # 한 세트 거치고 나면 cnt 1 증가

print(cnt)     # 마칠 때까지 진행된 단계 출력