def solution(n):
    # 1. n x n 2차원 배열 생성
    snail = [[0] * i for i in range(1, n + 1)]     # 삼각형 배열 생성 (계단식)
    
    # 2. 반시계 방향(시작은 아래로)의 나선형 형태로 배열을 채워나감.
    # 반시계 방향으로 돌아가므로 밑으로 1칸씩 (y가 1씩 증가, x 그대로(index 0)) --> 오른쪽으로 1칸씩 (x가 1씩 증가, y 그대로) 
    # --> 위쪽으로 1칸씩 (y가 1씩 감소, x도 1씩 감소 (칸 수가 줄어드므로)), 이것 반복
    # 이 증감 과정을 차례로 변수에 담으면 각각 dx와 dy가 됨.
    dx = [0, 1, -1]     # x축 방향 이동을 위한 변수 (차례로 그대로, 오른쪽으로 1칸, 좌측으로 1칸)
    dy = [1, 0, -1]     # y축 방향 이동을 위한 변수 (차례로 아래로 1칸, 그대로, 위로 1칸)
    x = y = angle = 0     # x와 y의 초깃값을 0으로 하여 snail[0][0] 부터 숫자가 채워지도록 함, angle은 방향을 설정하는 인덱스로 역시 초깃값 0이다.
    cnt = 1     # snail에 들어갈 숫자
    size = (n + 1) * n // 2     # len(snail) 과 같다.
    while cnt <= size:     # cnt가 snail에 들어갈 마지막 숫자가 되기까지 반복
        snail[y][x] = cnt     # 배열에 cnt 할당
        ny = y + dy[angle]     # ny는 다음에 적용될 인덱스, 방향에 따라 값이 달라짐.
        nx = x + dx[angle]     # nx 또한 다음에 적용될 인덱스, 방향에 따라 값이 달라짐.
        cnt += 1     # cnt를 1 증가시켜 들어갈 숫자를 업데이트
        
        # 3. 배열의 끝에 닿으면 방향을 변경한다.
        # 없는 인덱스를 참조하거나, 다음 배열이 이미 값이 다 할당되어 있는 배열이라면 충돌로 판정하여 진행 방향을 변경한다.
        
        # - 0 <= ny < n and 0 <= nx <= ny 조건은 없는 인덱스를 참조하는지를 확인하는 조건이다.
        # - and snail[ny][nx] 조건은 다음 배열에 값이 이미 할당되어 있는지를 확인하는 조건이다.
        if 0 <= ny < n and  0 <= nx <= ny and snail[ny][nx] == 0:
            y, x = ny, nx     # 위 조건들이 모두 true이면 현재 방향이 제대로 가고 있는 것이 맞으므로 y, x에 ny와 nx의 값을 할당한다.
        else:     # 위 조건이 만족하지 않으면 충돌이 일어나는 것이므로 방향을 바꾸어야 한다.
            angle = (angle + 1) % 3     # angle은 0부터 2까지 가능, 현재 angle에서 1이 증가하거나 현재 angle이 2일 경우에는 0으로 다시 되돌아가야 한다. 그것을 일반화한 식은 옆과 같다.
            y += dy[angle]     # 현재 y에다 dy[angle]을 더한 값을 y에 할당 
            x += dx[angle]     # 현재 x에다 dx[angle]을 더한 값을 x에 할당
    
    # 4. 삼각형을 모두 채웠다면 배열을 1차원으로 만들어 정답을 제출
    return [i for j in snail for i in j] 